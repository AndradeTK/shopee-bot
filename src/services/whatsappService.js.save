// No início do arquivo
const {
  default: makeWASocket,
  useMultiFileAuthState,
  DisconnectReason,
  downloadMediaMessage,
} = require("@whiskeysockets/baileys");
const pino = require("pino");
const qrcode = require("qrcode-terminal");
const axios = require("axios");
const { Boom } = require("@hapi/boom");
const fs = require("fs");
const path = require("path");
const { log } = require("./loggerService");
const { insertMessage } = require("./databaseService");

// Guarda a instância da conexão do socket
let sock;
const N8N_WEBHOOK_URL = process.env.N8N_WEBHOOK_URL;

// Lê as configurações do arquivo JSON
const settingsFilePath = path.join(__dirname, "../../config/settings.json");
const settings = JSON.parse(fs.readFileSync(settingsFilePath));
const MONITOR_GROUP_ID = settings.monitorGroupId;

async function connectToWhatsApp(io) {
  const { state, saveCreds } = await useMultiFileAuthState("session");

  sock = makeWASocket({
    auth: state,
    logger: pino({ level: "silent" }),
  });

  sock.ev.on("connection.update", (update) => {
    const { connection, lastDisconnect, qr } = update;


    if (connection === "close") {
      const shouldReconnect =
        (lastDisconnect.error instanceof Boom)?.output?.statusCode !==
        DisconnectReason.loggedOut;
      console.log(
        "Conexão fechada devido a ",
        lastDisconnect.error,
        ", reconectando...",
        shouldReconnect
      );
      if (shouldReconnect) {
        connectToWhatsApp();
      }
    } else if (connection === "open") {
      console.log("Conexão com o WhatsApp aberta!");
    }
  });

  // Bloco de recebimento de mensagens, agora refatorado e mais limpo
  sock.ev.on("messages.upsert", async (m) => {
    const msg = m.messages[0];
    if (!msg.message || !msg.key.remoteJid) return;

    const remoteJid = msg.key.remoteJid;

    // Ignora conversas privadas, foca apenas em grupos
    if (!remoteJid.endsWith("@g.us")) return;

    // Pega o conteúdo da mensagem (legenda ou texto) UMA ÚNICA VEZ
    const messageText =
      msg.message.conversation ||
      msg.message.extendedTextMessage?.text ||
      msg.message.imageMessage?.caption ||
      msg.message.videoMessage?.caption;

    // Se não houver texto/legenda, não há nada a fazer.
    if (!messageText) return;

    console.log("Mensagem recebida de:", remoteJid);

    // Salva TODAS as mensagens de grupo com texto no banco de dados para a "Caixa de Entrada"
    try {
      const senderName = msg.pushName || "Desconhecido";
      const metadata = await sock.groupMetadata(remoteJid);
      const groupName = metadata.subject;
      insertMessage({
        groupId: remoteJid,
        groupName,
        senderName,
        messageText,
      });
    } catch (e) {
      log("ERROR", "Falha ao salvar mensagem no banco de dados", { error: e.message });
      console.error(
        "Erro ao obter metadados ou salvar mensagem no banco de dados:",
        e.message
      );
    }

    // AGORA, verifica se a mensagem é do grupo que queremos MONITORAR para enviar ao n8n
    if (remoteJid === MONITOR_GROUP_ID) {
      log("INFO", `Mensagem recebida do grupo monitorado ${remoteJid}`);
      let imageBase64 = null;

      // Se for uma imagem, tenta baixar a mídia
      if (msg.message.imageMessage) {
        console.log("Detectada imagem. Baixando mídia...");
        try {
          const buffer = await downloadMediaMessage(msg, "buffer", {});
          imageBase64 = buffer.toString("base64");
          console.log("Mídia baixada com sucesso.");
        } catch (e) {
          log("ERROR", "Falha ao baixar mídia", { error: e.message });
          console.error("Erro ao baixar mídia:", e);
        }
      }

      // Envia os dados coletados para o n8n
      try {
        await axios.post(N8N_WEBHOOK_URL, {
          caption: messageText, // Usa o messageText que já extraímos
          imageBase64: imageBase64, // Será a imagem em base64 ou null
          from: remoteJid,
        });
        console.log("Dados enviados para o n8n com sucesso!");
      } catch (error) {
        log("ERROR", "Falha ao enviar dados para o n8n", { error: error.message });
        console.error("Erro ao enviar dados para o n8n:", error.message);
      }
    }
  });

  sock.ev.on("creds.update", saveCreds);
}

// Função para enviar mensagens (já estava correta)
async function sendMessage(targetGroups, caption, imageBase64) {
  if (!sock) {
    throw new Error("WhatsApp não está conectado.");
  }
  try {
    for (const groupId of targetGroups) {
      if (imageBase64) {
        // Se tiver imagem, envia imagem com legenda
        const imageBuffer = Buffer.from(imageBase64, "base64");
        await sock.sendMessage(groupId, {
          image: imageBuffer,
          caption: caption,
        });
      } else {
        // Se não, envia só texto
        await sock.sendMessage(groupId, { text: caption });
      }
      log("INFO", `Mensagem reenviada para o grupo de destino ${groupId}`);
      console.log(`Mensagem enviada para o grupo ${groupId}`);
    }
    return { status: "success", message: "Mensagens enviadas com sucesso." };
  } catch (error) {
    log("ERROR", "Falha ao enviar mensagem via WhatsApp", { error: error.message });
    console.error("Erro ao enviar mensagem:", error);
    throw new Error("Falha ao enviar mensagem via WhatsApp.");
  }
}

module.exports = { connectToWhatsApp, sendMessage };
